---
title: 数据库语言--SQL
date: 2022-01-18 10:22:28
tags: 数据库
---

# 数据库语言——SQL

SQL语言主要由九个单词引导的操作语句来构成，但每种语句都能表达复杂的操作请求

+ DDL语句引导词：Create (建立)，Alter（修改），Drop（撤销）
  + 模式的定义和删除，包括定义Database，Table，View，Index,完整性约束条件等，也包括定义对象（RowType行对象，Type列对象）

+ DML语句引导词：Insert，Delete，Update，Select
  + 各种方式的更新与检索操作，如直接输入记录。或者从其他Table(由SubQuery建立)输入
  + 各种复杂条件的检索，如链接查找，模糊查找，分组查找，嵌套查找等
  + 各种聚集操作，求平均，求和,...等，分组聚集，分组过滤等

+ DCL语句引导词：Grant，Revoke
  + 安全性控制：授权和撤销授权

交互式SQL->嵌入式SQL->动态式SQL

## 建立数据库

建立数据库包括两件事：**定义数据库和表（使用DDL）**，向表中追加元素（使用DML）

DDL: Data Definition Language

+ 创建数据库（DB）-Create Database
+ 创建DB中的Table(定义关系模式)--Create Table
+ 定义Table及其各个属性的约束条件（定义完整性约束）
+ 定义View(定义外模式及E-C映像)
+ 定义Index、Tablespace.....等（定义物理存储参数
+ 上述各种定义的撤销与修正

###  创建Database

+ 数据库是若干具有相互关联关系的Table/Relation的集合
+ 数据库可以看作是一个集中存放若干Table的大型文件
+ create database的简单语法形式  

```sql
create database 数据库名
```

### 创建Table

简单语法形式：

```sql
create table 表名(列名 数据类型 [Primary key|Unique][Not null]
				[列名 数据类型 [Not null],...]);
```

+ “[ ]”表示其括起的内容可以省略，”|“表示其隔开的两项可取其一
+ **Primary key**：主键约束。每个表只能创建一个主键约束。
+ **Unique**：唯一性约束（候选键）。可以由多个唯一性约束
+ **Not null**：非空约束。是指该列允许不允许有空值出现。如选择了Not null则表明不允许有空值出现

## 数据库追加元素

建立数据库包括两件事：定义数据库和表（使用DDL）**，向表中追加元素（使用DML）**

DML:Data Manipulation Language

+ 向Table中追加新的元组：Insert
+ 修改某些元组中的某些属性：Update
+ 删除Table中的某些元组：Delete
+ 对Table中的数据进行某种条件的检索：Select

DML通常由用户或应用程序员使用，访问经授权的数据库

### Insert-向表中追加元组

```sql
insert Into 表名[(列名 [,列名]...)] 
       values (值 [,值],...);
```

+ values后面值的排列，需与into子句后面的列名排列一致
+ 若标名后的所有列名省略，则values后的值的排列，需与该表存储的列名排列一致

![image-20210123153337564](数据库语言——SQL/image-20210123153337564.png)

![image-20210124120838523](数据库语言——SQL/image-20210124120838523.png)

### Delete-删除表中元组

```sql
Delete From 表名 [Where 条件表达式]
```

如果where条件省略，则删除所有的元素

### Update-更新表中元组

```sql
Update 表名
Set 列名=表达式|(子查询)
    [[,列名=表达式|(子查询)]...]
[Where 条件表达式]; 
```

如果where 条件省略，则更新所有元组

### Select-检索信息

```sql
Select 列名 [[，列名]...]
From   表名
[Where 检索条件];
```

+ 语义：从表名所给出的表中，查询出满足检索条件的元组，并按给定的列名及顺序进行投影显示
+ 相当于$\prod_{列名,...,列名}(\sigma_{检索条件}(表名))$
+ Select语句中的select....,from...,where...,等被称为子句，在以上基本形式基础上会增加许多构成要素，也会增加许多新的子句，满足不同的需求。
+ 检索条件用 and，or，not 来表达

#### 结果唯一性问题

![image-20210123163053033](数据库语言——SQL/image-20210123163053033.png)

#### 结果排序问题

![image-20210123171125801](数据库语言——SQL/image-20210123171125801.png)

#### 模糊查询问题

比如检索只知道姓氏的学生，Select通过在检索条件中引入运算符like来表示

含有like运算符的表达式

​	列名 [not] like “字符串”

找出匹配给定字符串的字符串，其中给定字符串中可以出现%,__等字符，

匹配规则：

+ %：匹配零个或多个字符
+ _：任意匹配单个字符
+ \：转义字符，用于去掉一些特殊字符的特定含义，使其被作为普通字符看待

#### 多表联合查询

多表联合检索可以通过链接运算来完成，而链接运算又可以通过广义笛卡儿积后再进行选择运算来实现。

Select的多表联合查询检索语句

```sql
Select 列名 [[,列名]...] 
From   表名1,表名2,...
Where  检索条件;
```

检索条件中要包括链接条件，通过不同的链接条件可以实现等值链接，不等值链接以及各种$\theta-$链接

![image-20210124105502924](数据库语言——SQL/image-20210124105502924.png)

##### 重名处理

连接运算涉及到重名的问题时，如两个表的属性重名，连接的两个表重名（同一表的连接）等，因此需要使用别名以便区分

select中采用别名的方式

```sql
Select 列名 as 列别名[[,列名 as 列别名]...]
From 表名1 as 表别名1，表名2 as 表别名2,...
Where 检索条件
```

+ 上述定义中的As可以忽略
+ 当定义了别名之后，在检索条件中可以使用别名来限定属性 

## 修正数据库

修正数据库主要是修正表的定义

##### 表单修改

```sql
alter table tablename
[add {colname datatype,...}]          增加新列
[drop {完整性约束名}]                   删除完整性约束
[modify {colname datatype,...}]       修改列定义
```

##### 撤销基本表

```sql
drop table 表名                       撤销表
drop database 数据库名                 撤销数据库
```

注意:delete是删除表中的数据，drop是将整个表单删除

## 数据库指定与关闭

##### 指定当前数据库

```sql
use 数据库名
```

##### 关闭当前数据库

```sql
close 数据库名
```

## 复杂查询

### 子查询

#### 为什么需要子查询

很多情况需要下述条件的判断

+ 集合成员资格
  + 某一元素是否是某一个集合成员

+ 集合之间的比较
  + 某一集合是否包含另外一个集合等

+ 集合基数测试
  + 测试集合是否为空
  + 测试集合是否存在重复元组

子查询：出现在Where子句中的Select语句被称为子查询(subquery)，子查询返回了一个集合，可以通过与这个集合的比较来确定另一个查询集合

三种类型的子查询：(NOT)IN-子查询;$\theta-Some/\theta-All$子查询；Exist子查询

##### (NOT)IN-子查询：

```sql
[not] in 子查询
```

语法中，表达式最简单的形式就是列名或常数

语义：判断某一表达式的值是否在子查询的结果中

示例：列出选修了001号课程的学生的学号和姓名

```sql
Select S#,Sname From Student
Where S# in (Select S# From SC Where C#="001")
```

非相关子查询：内层查询独立进行，没有涉及任何外层查询相关信息的子查询

相关子查询：内层查询需要依靠外层查询的某些参量作为限定条件才能进行的子查询

外层向内层传递的参量需要使用外层的表名或者表别名来限定

##### $\theta-Some/\theta-All$子查询

```sql
表达式 theta some (子查询)
表达式 theta all (子查询)
```

语法中的$\theta$是比较运算符：<,>,>=,<=,<>,=

语义：将表达式的值与子查询结果进行比较

+ 如果表达式的值至少与子查询结果的一个值比较满足$\theta$关系，则“表达式 theta some (子查询)”的结果便为真
+ 如果表达式的值与子查询的所有结果比较都满足$\theta$关系，则“表达式 theta all (子查询)”的结果便为真

##### Exist子查询

![image-20210124173533484](数据库语言——SQL/image-20210124173533484.png)

### 结果计算

Select-from-where语句中，Select子句后面不仅可是列名，而且可是一些计算表达式或聚集函数，表名在投影的同时直接进行一些运算

```sql
Select 列名|expr|agfunc(列名) [[,列名|expr|agfunc(列名)]...]
From   表名[,表名2...]
[Where 检索条件];
```

+ expr 可以是常量、列名、或由常量、列名、特殊函数及算数运算符构成的算数运算式。特殊函数的使用需结合各自DBMS的说明书
+ agfunc()是一些聚集函数

### 分组查询

分组：SQL可以将检索到的元组按照某一条件进行分类，具有相同条件值的元组放到一个组或一个集合中，同时处理多个组或聚合的聚集运算

分组基本语法：

```sql
Select 列名|expr|agfunc(列名) [[,列名|expr|agfunc(列名)]...]
From   表名1[,表名2...]
[Where 检索条件]
[Group by 分组条件];
```

分组条件可以是

列名1，列名2,...

![image-20210124210211441](数据库语言——SQL/image-20210124210211441.png)

### 分组过滤

引入原因：Where子句是对每一元组进行条件过滤而不是对集合进行条件过滤

**分组过滤：**对集合进行条件过滤，满足条件的集合留下，不满足的剔除

Having子句，又称分组过滤子句。需要有groupBy 子句支持

```sql
Select 列名|expr|agfunc(列名) [[,列名|expr|agfunc(列名)]...]
From   表名1[,表名2...]
[Where 检索条件]
[Group by 分组条件[Having 分组过滤条件]];
```

### 并-交-差的处理

并运算UNION，交运算INTERSECT，差运算EXCEPT。

基本语法形式：

```sql
子查询 {Union [ALL]|intersect[ALL]|Except[ALL] 子查询}
```

通常情况下自动删除重复元组：不带ALL。若要保留重复元组则要带ALL

![image-20210124214232604](数据库语言——SQL/image-20210124214232604.png)

### 数据库视图

![image-20210126190548381](C:\Users\Yokeso\AppData\Roaming\Typora\typora-user-images\image-20210126190548381.png)

![image-20210126190607776](C:\Users\Yokeso\AppData\Roaming\Typora\typora-user-images\image-20210126190607776.png)

SQL视图更新的可执行性

+ 如果视图的Select目标列包含聚集函数，则不能更新
+ 如果视图的select子句使用了unique或distinct，则不能更新
+ 如果视图中包括了group by子句，则不能更新
+ 如果视图中包括经算数表达式算出来的列，则不能更新、
+ 如果视图是由单个表的列构成，但并没有包括主键，则不能更新

对于由单一Table子集构成的视图，即如果视图是从单个基本表使用选择，投影操作的，并且包含了基本表的主键，则可以更新

### SQL-视图的撤销

已经定义的视图可以撤销

###### 撤销视图

```sql
Drop View view_name
```

